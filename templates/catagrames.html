<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- to avoid 300ms touchscreen delay... -->
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=3">
    <title>CATAGRAMA del dia</title>

    <!-- favicon -->
    <link rel="icon" type="image/x-icon" href="/static/icons/catagrama_favicon.png">
    <!--icon for home screen -->
    <link rel="apple-touch-icon-precomposed" sizes="128x128" href="/static/icons/catagrama128.png">
    <link rel="shortcut icon" sizes="128x128" href="/static/icons/catagrama128.png">

    <script>
        //////// Classes ///////
        class letterBox {
          constructor(x, y, w, h, cypherLetter, num){
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.letter = cypherLetter;
            this.num = num;
          }
        }
        class quertyKey {
          constructor(x, y, w, h, letter){
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.letter = letter;
          }
        }
        class AjaxRequest {
          constructor(result, done=false){
            this.result = result;
            this.done = done;
          }
        }
        //////// GLOBAL VARS //////
        var cWidth;
        var cHeight;
        var u;
        var colors = {
          "bg": "#1990bd",
          "bg_correct": "#55bd19",
          "bg_wrong": "#bd1924",
          "main": "#4bb4db",
          "main_correct": "#80db4b",
          "main_wrong": "#db4b55",
          "active": "#24404d",
          "collateral": "#70909e",
          "quertyshade": "#99b9c7",
        }
        var cc;

        // main space
        var gX;
        var gY;
        var gW;
        var gH;

        // quote measures
        var quoteY;
        var MONO;
        var plainH;
        var heatH;
        var cypherH;
        var qLineH;

        // game
        var quote = {{quote | tojson}};
        var author = {{author | tojson}};
        var quote_num = "#" + {{num | tojson}};
        var quote_id = {{quote_id | tojson}};
        var plain = {{plain | tojson}};
        var alpha = {{alpha | tojson}};
        var plainphabet = {{plainphabet | tojson}};
        var cypher = {{cypher | tojson}};
        var freqs = {{freqs | tojson}};
        var userAlpha = "?".repeat(alpha.length);
        var maxFreq;

        // UI
        var quertyRows = ["QWERTYUIOP", "ASDFGHJKLÇ", "ZXCVBNM<<"];
        var quertyY;
        var keyW;
        var keyH;
        //
        var quoteBoxes = [];
        var activeBox = 0;
        var quertyKeys = [];
        //
        var correction = 0;  // -1 mal, 0 neutro, 1 bien
        //
        var t_start;
        var t_end;
        var t_pause_start = -42;

        // UI debug
        var pressed = [0, 0];

        // AJAX
        var submitTime = new AjaxRequest();

        ///////// onload //////
        window.onload = function(){
            c=document.getElementById("app");

            // medidas
            set_measures();

            // precálculos
            maxFreq = getMaxFreq();

            // drawing init
            cc = c.getContext("2d");
            update();
            setInterval(update, 1000);  // fallback update 1s (normalmente será onclick)

            // ui init
            init_quote_boxes();
            init_querty();
            init_collisions(c);

            // prevent space going down
            window.addEventListener("keydown", function(e){
                if((e.key==" ") && document.activeElement==c){
                    e.preventDefault();
                }
            }, false);

            // on resize
            window.addEventListener("resize", function(){
              set_measures();
              init_quote_boxes();
              init_querty();
              update();
            }, true);

            update();

            // start clock
            t_start = Date.now();
            t_end = Date.now() - 42;

            // focus
            c.focus();
        }

        function set_measures(){
          let resolution = 5;
          c.width = window.innerWidth * resolution;
          c.height = window.innerHeight * resolution;
          cWidth = c.width;
          cHeight = c.height;
          u = cHeight/500;

          // main space w/h
          gH = cHeight;
          gW = cWidth < cHeight ? cWidth : cHeight/1.3;
          gY = 0;
          gX = cWidth/2 - gW/2;

          // UI elements
          quoteY = 75*u;
          keyW = gW/(quertyRows[0].length+0.4);
          keyH = keyW * 0.95;
          quertyY = cHeight-(0.2+quertyRows.length)*keyH;
          MONO = 15*u;
          set_quote_measures();
        }

        function set_quote_measures(){
          plainH = MONO*1;
          heatH = MONO*0.6;
          cypherH = MONO*0.8;
          qLineH = (plainH + heatH + cypherH) * 1.1;
        }

        ///////// Update ////////
        function update(){
            // style setup
            cc.textBaseline = "middle";
            cc.textAlign = "center";
            cc.lineJoin = 'miter';
            cc.miterLimit = 2;

            // bg
            let bg_color = correction < 0 ? colors.bg_wrong
                            : correction > 0 ? colors.bg_correct
                            : colors.bg;
            cc.fillStyle = bg_color;
            cc.fillRect(0, 0, c.width, c.height);

            // main portrait
            cc.fillStyle=correction < 0 ? colors.main_wrong
                            : correction > 0 ? colors.main_correct
                            : colors.main;
            cc.fillRect(cWidth/2-gW/2, 0, gW, gH);

            // title
            cc.lineWidth = 1*u;
            cc.font = font("Helvetica", 30, bold=true);
            cc.fillStyle = "white";
            cc.fillText("CATAGRAMA", gX+gW/2, 25*u);
            if(correction == 1){
              cc.font = font("Helvetica", 13);
              cc.fillText("Resolt en " + get_time(t_end, t_start), gX+gW/2, 45*u);
            }else{
              /* debugging timer
              cc.font = font("Helvetica", 15);
              cc.fillText(get_time(Date.now(), t_start), gX+gW/2, 45*u);
              */
            }
            cc.font = font("Helvetica", 10, bold=true);
            cc.textAlign = "left"
            cc.fillStyle = "rgba(255, 255, 255, 0.5)";
            cc.fillText(quote_num, gX + MONO, quoteY-12*u);
            cc.fillStyle = "white";
            let quote_num_len = cc.measureText(quote_num).width;
            cc.fillText(author, gX + MONO + quote_num_len + 4*u, quoteY-12*u);
            cc.font = font("Helvetica", 10);
            cc.fillText("WIP: això serà un trencaclosques diari rollo Wordle o Paraulògic. Aviat :)", gX + MONO, quertyY-2*MONO);
            cc.textAlign = "center"

            // main UI
            cc.lineWidth = 1*u;
            draw_quote();
            draw_querty();

            // ////// DEBUGGING //////
            // alphabets debug
            cc.fillStyle = "purple";
            //cc.fillRect(pressed[0]-2*u, pressed[1]-2*u, 4*u, 4*u);
        }

        function font(family, pt, bold=false, italic=false){
          let type = "";
          if(italic){
            type += "italic ";
          }
          if(bold){
            type += "bold ";
          }
          return type + (pt*gW/400).toString() + "px " + family;
        }

        function monofont(family, pt){
          return (MONO*pt/20).toString() + "px " + family;
        }

        function draw_quote(){
          for(let box of quoteBoxes){
            draw_letterbox(box);
          }
        }

        function draw_letterbox(box){
          let x = box.x;
          let y = box.y;
          let letter = box.letter;
          let plainBG;
          let plainColor;
          if(box.num == activeBox && correction != 1){
            plainBG = colors["active"];
            plainColor = "#ffffff";
          }else if(box.letter == quoteBoxes[activeBox].letter && correction != 1){
            plainBG = colors["collateral"];
            plainColor = "#ffffff";
          }else{
            plainBG = "white";
            plainColor = "black";
          }
          if(alpha.includes(letter)){
            // main
            cc.fillStyle = plainBG;
            cc.fillRect(x, y, MONO, plainH);
            cc.font = monofont("Courier", 20);
            cc.fillStyle = plainColor;
            let plainletter = ralph(letter, alpha, userAlpha);
            if(plainletter != "?"){
              cc.fillText(plainletter, x+MONO/2, y+plainH/2);
            }
            // cipher
            cc.fillStyle = "lightgrey";
            cc.fillRect(x, y+plainH+heatH, MONO, cypherH);
            cc.font = monofont("Courier", 16);
            cc.fillStyle = "black"
            let offset = letter == "Ç" ? cypherH*0.44 :
                         letter == "Q" ? cypherH*0.45 : cypherH*0.5;
            cc.fillText(letter, x+MONO/2, y+plainH+heatH+offset)
            // heatmap
            cc.fillStyle = freqColor(letter);
            cc.fillRect(x, y+plainH, MONO, heatH);
            cc.strokeRect(x, y+plainH, MONO, heatH);
            cc.font = monofont("Courier", 10);
            cc.fillStyle = "black";
            cc.fillText(freqs[letter], x+MONO/2, y+plainH+heatH/2);
            // global border
            cc.strokeStyle = "black";
            cc.strokeRect(x, y, MONO, plainH+heatH+cypherH);
          }else{
            cc.fillStyle = "black";
            cc.font = monofont("Courier", 20);
            cc.fillText(letter, x+box.w/2, y+plainH/2);
          }
        }

        function draw_querty(){
          let backdrawn = false;
          let x;
          let y;
          let w;
          let h;
          let m;
          for(let k of quertyKeys){
            m = k.w*0.1;
            h = k.h;
            y = k.y;
            if(k.letter == "<"){
              if(backdrawn){
                continue;
              }else{
                w = 2*k.w;
                x = k.x+k.w/2;
                backdrawn = true;
              }
            }else{
              w = k.w;
              x = k.x;
            }
            h -= m;
            w -= m;
            cc.fillStyle = userAlpha.includes(k.letter) ? colors.quertyshade : "white";
            roundRect(cc, x-w/2, y-h/2, w, h, h/10);
            if(k.letter == "<"){
              cc.fillStyle = "#bbbbbb";
              cc.font = font("Helvetica", 15);
              cc.fillText("elimina", x, y+h*0.02);
            }else{
              cc.fillStyle = "black";
              cc.font = font("Helvetica", 22);
              cc.fillText(k.letter, x, y+h*0.04);
            }
          }
        }

        function roundRect(cc, x, y, w, h, r, stroke=true, fill=true){
          cc.beginPath();
          cc.roundRect(x, y, w, h, r);
          if(fill){
            cc.fill();
          }
          if(stroke){
            cc.stroke();
          }
        }

        function getMaxFreq(){
          let max = 1;
          for(let [letter, quantity] of Object.entries(freqs)){
            max = Math.max(max, quantity);
          }
          return max;
        }

        function freqColor(letter){
          let lowest = [250, 230, 55];  // amarillo
          let highest = [250, 81, 55];  // rojo
          let k = freqs[letter] / maxFreq;

          let color = [lowest[0]*(1-k) + highest[0]*k,
                       lowest[1]*(1-k) + highest[1]*k,
                       lowest[2]*(1-k) + highest[2]*k,
                       ];
          return "rgb("+ color[0] + "," + color[1] + "," + color[2] + ")";
        }

        function ralph(letter, older, newer){
          // replace alphabet
          return newer[older.indexOf(letter)];
        }

        function place_letter(letter){
          let cypherLetter = quoteBoxes[activeBox].letter;
          if(userAlpha.includes(letter)){
            userAlpha = replace_at_index(userAlpha, userAlpha.indexOf(letter), "?");
          }
          userAlpha = replace_at_index(userAlpha, alpha.indexOf(cypherLetter), letter);

          // reset correction & search for next
          correction = 0;
          to_next_empty();
        }

        function replace_at_index(string, index, char){
          let newString = string.substring(0, index) + char + string.substring(index+1);
          return newString;
        }

        function delete_letter(){
          userAlpha = replace_at_index(userAlpha, alpha.indexOf(quoteBoxes[activeBox].letter), "?");
          correction = 0;
        }

        function to_next_empty(){
          for(j=1; j<quoteBoxes.length; j++){
            let k = (activeBox+j) % quoteBoxes.length;
            if(alpha.includes(quoteBoxes[k].letter)){  // és lletra
              if(userAlpha[alpha.indexOf(quoteBoxes[k].letter)] == "?"){
                activeBox = k;
                return;
              }
            }
          }
          // else
          check_quote();
        }

        function to_next(right=true){
          let k;
          for(j=1; j<quoteBoxes.length;j++){
            if(right){
              k = (activeBox+j) % quoteBoxes.length;
            }else{
              k = (activeBox-j) % quoteBoxes.length;
              if(k<0){
                k += quoteBoxes.length;
              }
            }
            if(alpha.includes(quoteBoxes[k].letter)){
              activeBox = k;
              return;
            }
          }
        }

        function check_quote(){
          // strip unused
          let guessed = userAlpha;
          guessed = guessed.replaceAll("?", "");
          // strip non appearing
          let correct = plainphabet;
          for(let lletra of plainphabet){
            if(!plain.includes(lletra)){
              correct = correct.replace(lletra, "");
            }
          }
          correction = guessed == correct ? 1 : -1;
          if(correction == 1 && t_end < t_start){
            t_end = Date.now();
            ajax("submit_time_" + quote_id + "_" + (t_end-t_start).toString(), submitTime);
          }
        }

        function get_time(end, start){
          let msec = end - start;
          //
          let sec = Math.floor(msec / 1000);
          msec -= sec * 1000;
          //
          let min = Math.floor(sec / 60);
          sec -= min * 60;

          return time_text = min + ":" + sec.toString().padStart(2, "0");
        }

        // unfocus
        window.addEventListener("blur", function(){
          t_pause_start = Date.now();
        }, true);
        // refocus
        window.addEventListener("focus", function(){
          if(t_pause_start != -42 && correction != 1){
            t_start += Date.now() - t_pause_start;  // compensate for pause time
          }
          t_pause_start = -42;
        }, true);

        ///////////////// KeyUp ////////////////
        function canvas_hotkeys(e){
            let upperKey = e.key.toUpperCase();
            if(correction != 1){
              if(alpha.includes(upperKey)){
                place_letter(upperKey);
              }else if(e.key == "Backspace"){
                delete_letter();
              }else if(e.key == "ArrowLeft"){
                to_next(right=false);
              }else if(e.key == "ArrowRight"){
                to_next();
              }
            }
            update();
        }

        /////////// Clicks ////////////
        // Init quoteBoxes
        function init_quote_boxes(){
          quoteBoxes = [];
          let words = cypher.split(" ");
          let x = gX+MONO;
          let y = quoteY;
          let i=0;
          for(let word of words){
            if(x + (word.length+3) * MONO> gX + gW){
              x = gX+MONO;
              y += qLineH;
              // check for keyboard overlap = make smaller
              if(y + qLineH > quertyY-keyH){
                MONO *= 0.8;
                console.log(MONO);
                set_quote_measures();
                init_quote_boxes();  // recursive retry
                break;
              }
            }
            for(let letter of word){
              let w = alpha.includes(letter) ? MONO : MONO*2/3;
              quoteBoxes.push(new letterBox(x, y, w, plainH + heatH + cypherH, letter, i));
              x += w;
              i++;
            }
            x += MONO*2/3;
          }
          update();
        }

        function init_querty(){
           quertyKeys = [];
           let y = quertyY;
           for(let row of quertyRows){
             i = 0;
             let x0 = gX+gW/2-keyW*(row.length-1)/2;
             for(let letter of row){
               quertyKeys.push(new quertyKey(x0+keyW*i, y, keyW, keyH, letter));
               i++;
             }
             y += keyH;
           }
        }
        // Collisions (partially StackOverflow)
        function init_collisions(c){
            c.addEventListener('click', function(event){
                const rect = c.getBoundingClientRect();
                const relX = event.clientX - rect.left;
                const relY = event.clientY - rect.top;
                x = relX * c.width / rect.width;
                y = relY * c.height / rect.height;

                xcur = x;
                ycur = y;
                pressed = [xcur, ycur];

                if(correction != 1){
                  let i = 0;
                  for(let b of quoteBoxes){
                      if(y < b.y+b.h && x < b.x+b.w && x > b.x && y > b.y){  // rollin LTR: bulk discard (last 2 conditions checked only if found)
                          activeBox = i;
                          update();
                          return;
                      }
                      i++;
                  }
                  for(let k of quertyKeys){
                    if(y < k.y+k.h/2 && x < k.x+k.w/2 && x > k.x-k.w/2 && y > k.y-k.h/2){
                      if(alpha.includes(k.letter)){
                        place_letter(k.letter);
                      }else{
                        delete_letter();
                      }
                      update();
                      return;
                    }
                  }
                }

                update();
            }, false);
        }

        ///////////////// AJAX HANDLER //////////////

        function ajax(url='', ajax_result=new AjaxRequest()){
          let req = new XMLHttpRequest();

          req.onreadystatechange = function(){
              if(this.readyState == 4 && this.status == 200) {
                  ajax_result.result = this.responseText;
                  ajax_result.done = true;
              }else{
                  ajax_result.done = false;
              }
          }

          console.log('/catagrama/ajax/' + url);
          req.open('GET', '/catagrama/ajax/' + url, true);
          req.send();
        }
    </script>
</head>
<body style="margin: 0; padding: 0;">
    <canvas id="app" tabindex="0" onkeyup="canvas_hotkeys(event);" style="width: 100%; height: 100%; display: block;"></canvas>
</body>
</html>
